---
title: "memory-access"
output: pdf_document
---

# Cache effects of memory accesses at different offsets 
A large array is accessed at offsets which are multiples of a certain step size and the time span required to traverse the whole array is recorded.

```c++
  // Relevant code
  auto data = std::vector<int>(64 * 1024 * 1024, 1);
  for(auto ii = 0u; ii < data.size(); ii += step_sz)
  {
    data[ii] *= 3;
  }
```

## Measurement results

```{r echo=FALSE}
suppressMessages(library(tidyverse))

data <- read.csv(file = "./data.csv") %>%
  as_tibble() %>%
  mutate(step_sz = factor(step_sz)) %>%
  group_by(step_sz) %>%
  summarize(duration_us_mean = mean(duration_us), duration_us_sd = sd(duration_us))

ggplot(data) +
  geom_point(aes(x = step_sz, y = duration_us_mean)) +
  labs(x = "Step size", y = "Duration [us]")
```

```{r echo=FALSE}
knitr::kable(data %>% select(-duration_us_mean), format="markdown")
```

L1 cache line size on this machine is 64 bytes (16 integers). Although the computational effort is four-fold the required time to complete the task is virtually identical between step sizes 4 and 16. It can be assumed that the overhead of having to load each cache line form memory outweighs the time required to do the computations, regardless of the number of arithmetic operations within this interval. For step sizes 1 and 2, however, the computation becomes relevant again.

The time keeps falling after the step size of 16 is surpassed, as with each larger step size less and less cache lines have to be loaded. While any step size between 1 and 16 requires that the maximum number of cache line loads are performed, and value larger than that skips a certain number of loads. A step size of 32 skips exactly every second cache line load etc. 